1) Python语言特点
a. 把高级语言翻译成机器语言有两种方式：一种是编译，一种是解释。其中解释是在程序运行时才对源代码进行逐条语句的翻译
并运行；解释性语言编写的程序每执行一次，就要翻译一次，翻译结果不会像编译型语言一样保存在可执行文件中，因此效率
较低。Python便是一种解释型语言，但是为了提高效率，Python程序在执行一次之后会自动生成扩展名为.pyc的字节码文件(主
程序文件不会生成字节码文件，只有调用的模块才会生成字节码文件)；下次再运行同一个Python程序时，只要源代码没有做过
修改，Python就直接将字节码文件翻译成机器语言再执行，大大提高效率。
b. Python官方提供了非常多的标准库代码，比如网络编程、输入输出、文件系统、图形处理、数据库、文本处理等。除了内置库还有很多第三方库，如用于科学计算的NumPy、用于Web开发的Django、用于网页爬虫的Scrapy、用于图像处理的OpenCV等。
c. Python是一种"胶水语言"，比如可以将不打算公开的部分关键模块、对速度要求高的模块等可以使用C或C++编写，然后在Python中使用它们，可以像胶水一样把这些模块黏合过来，让整个程序同时兼备其他语言的优点，起到了黏合剂的作用。
d. 与C/C++不同，Python的语句末尾不需要加分号，所以一行只能有一条语句。
e. Python使用强制缩进的方式来区分语句之间的关系，Python语言对行首缩进的方式没有严格的限制，既可以使用空格也可以使用制表符TAB，常用的对代码进行一个层次缩进的方式有：1个制表符、2个空格或4个空格。对于同一层次的代码，必须使用相同的缩进方式，否则会报错。
f. 使用Python的os模块可以方便地使用操作系统的相关功能；如创建目录、删除目录等；可以使用Thinter/PyQt框架开发各种桌面软件；Python提供的re模块能支持正则表达式，还提供SGML、XML分析模块，许多程序员使用Python进行XML程序开发；Python提供丰富的模块支持sockets编程,能方便地开发分布式应用程序；在金融分析领域利用Numpy、Pandas、SciPy等数据分析模块可快速完成数据分析工作；在多媒体领域Python的PyOpenGL模块封装了OpenGL应用程序编程接口，能进行二维和三维图像处理；在网络爬虫领域，Python几乎处于霸主地位，提供了Scrapy、Request、BeaufifulSoup、urllib等工具，将网络中的一切数据作为资源，通过自动化程序进行有针对性的数据采集以及处理；等等。
g. Python中的所有类型都是类类型，所有的变量都是类对象。
h. 在Python中一切皆对象：函数(属于function类)和类(int, list等)都是对象。
i. 在Python的PEP8规范中建议每行代码不超过79个字符。
j. 在Python3.x的语言环境中，默认使用UTF-8编码，因此可以直接支持中文。
h. Python是一种弱类型的语言，变量的类型由其值的类型决定。

2) 模块
    a. 如何避免这个问题：当一个脚本文件单独执行时就执行这些语句，而作为模块导入时，就不执行这些语句。
        a1. 要实现这个功能，需要用到每个模块中都有的一个全局变量__name__。__name__的作用是获取当前模块的名称，如果当前模块是单独执行的，则其__name__的值就是__main__；否则，如果是作为模块导入，则其__name__的值就是模块的名字。
        a2. 应用场景：在完成一个模块的编写之前，我们一般会对模块中的功能进行测试，对于这些测试代码，我们只希望在当前模中运行，而在其他程序import这个模块时不执行，就可以借助__name__来实现(将仅在当前模块中运行的代码放在
        if __name__ == '__main__'下的语句块中)。
    b. 通过在一个Python脚本文件中导入sys模块后，执行print(sys.argv), 即可看到输出的一个列表，其中第一个元素是脚本
       文件名。
    c. 无论是利用import导入模块，还是用from import导入模块中的标识符，在导入同时都可以使用as为模块或标识符起别名。
    d. 如果一个模块中定义了列表__all__，则"from 模块名 import *" 语句只能导入__all__列表中指定的标识符。比如在
       一个文件的第一行加入__all__列表的定义"__all__=['myfunc']",则在另一个文件通过from 模块名 import *导入时
       只能导入myfunc这个标识符，而不是全部的。
    e. 包(package)
        e1. 利用包可以将多个关系密切的模块组合在一起，定义一个包，就是创建一个文件夹并在该文件夹下创建一
        个__init__.py文件(该文件可以是一个空文件，也可以包含包的初始化代码，或者设置__all__列表；在新的Python版本中并不是必须要创建该文件？)，文件夹的名字就是包名。当然也可以在一个文件夹下再创建子文件夹，在子文件夹下创建一个__init__.py文件，则又形成了一个子包。模块可以放在任何一个包或子包中，在导入模块时，需要指定所在的包和子包的名字。例如，如果要导入包A中的模块B，则需要使用import A.B。
    f. 如果要使用A包的子包C的D模块(其中又d_func函数)，可以通过import A.C.D导入。那么在调用d_func函数时也必须指
       定完整的名字，即A.C.D.d_func(实参列表)。也可以使用from import方式导入包中的模块，如from A.C import D, 而且在调用D模块中的函数时不需要加包名，如：D.d_func(实参列表)；另外使用from import也可以直接导入模块中的标识符，如from A.C.D import d_func，此时调用d_func函数可直接写作：d_func(实参列表)
    g. pip的使用
        pip install --upgrade package-name  //让pip更新一个已安装的包, 比如pip install --upgrade pip更新pip
        pip install --user paceage-name //只为当前用户安装指定的包。

3) 单行注释用“#”, 多行注释以3个连续的单引号'''或3个连续的双引号"""作为开始符和结束符。

4) 查关键字的方法：
    a. help("keywords")
    b. import keyword
       print(keyword.kwlist)
    查内置函数的方法：
        import builtins
        print(dir(builtins))

5) 常用内置数据类型
    a. Number(数字，元素不可修改，即即不可变类型)
        a1. 有int(整型)、float(浮点型)、complex(复数类型)共三种不同的数字类型。
        a2. Python中提供了Boolean(布尔)类型，它是int的子类型，在作为数字参与运算时，False自动转为0，
            True自动转为 1。当给bool函数传入下列参数时，会返回Flase：定义为假的常量，包括None或Flase;
            任意值为0的数值，如0、0.0、0j等；空的序列或集合，如空字符串(''或"")、空元组(())、空列表([])等。
        a3. 浮点型使用C语言中的double类型实现。通过使用import sys和print(sys.float_info)可以查看当前
            环境中浮点数的取值范围和精度。
        a4. 复数的实部和虚部都是一个浮点数。在生成复数时，也可以使用complex([real[,imag]])如果省略虚部imag,
            则返回的复数为real+0j。
    b. String(字符串，元素不可修改，即不可变的序列)
        b1. Python中不区分字符和字符串。
        b2. Python中的字符串可以写在一对单引号中，也可以写在一对双引号或一对三双引号中。
        b3. Python中，对序列的下标有二种索引方式，从前向后索引(第一个字符下标为0)和从后向前索引(最后一个字符
            下标为-1，其他字符的下标是后一个字符下标减1)。截取子串(切片，方法为s[start:stop]或s[start:stop:step]或silce(start:stop:step)，其中不包括stop位置上的这个字符，如果省略start则表示从第一个元素开始，如果省略stop则表示从start位置开始一直到最后一个元素)时既可以使用其中一种下标索引方式，也可以
            同时混合使用。
        b4. 如果要截取字符串的一个字符可以使用s[idx]。
        b5. 使用下标[]虽然可以访问字符串中的元素，但是不能修改。例如s[1] = '1'就会报错。
        b6. 空字符串直接print(str(""))在屏幕上是看不到的，可以使用print([str("")])，这样的话会输出['']

    c. List(列表，元素可修改，即可变的序列)
        c1. 列表是可变的，这也意味着可随程序的运行增删元素，列表的长度会动态变化。需要注意的是列表中包含的元素
            类型可以不相同并且各元素地址并不一定是连续的，每个元素都有自己的地址。列表这个整体本身也有自己的地址。
        c2. 列表的索引方式与字符串中元素的索引方式完全相同。切片后返回的仍是一个列表；但是如果使用ls[idx]则返回的
            是其中的一个元素。
        c3. 需要注意和字符串不同的是使用ls[idx]还可以对元素进行修改。既可以通过ls[idx] = a这种方式修改单个元素
            的值(a可以是任意类型，包括列表)，也可以通过ls[start:stop] = b这种方式修改一个元素或同时修改连续多个元素的值(b可以是另一个列表)。
        c4. 创建一个起始于第一个元素终止于最后一个元素的切片[:]，会复制一个列表(创建一个副本)。

    d. Tuple(元组，元素不可修改，即不可变的序列)
        d1. 与list类似，不同的是元组的所有元素都在一对小括号()中，且元组中的元素不能修改。这里需要注意的是严格
            来说元组是由逗号标识的，小括号()只是让元组看起来更清晰而已。
            my_tuple = (3,)
            print(my_tuple) #(3,)
            my_tuple1 = 3,  #会封包成一个元组，如果只定义一个元素的元组必须加上逗号，若my_tuple1赋为3，输出3
            print(my_tuple1) #(3,)

    e. Set(集合，set是可变的，frozenset是不可变的)
        e1. 集合中也可以包含多个不同类型的元素，但集合中的各元素无序(集合中的元素是没有顺序的，输出不一定按照定义
            的顺序输出，并且每次输出的结果可能不一样)、不允许有相同的元素(集合会自动去重)且元素必须是可哈希的对
            象(可哈希对象是指拥有__hash()__(self)内置函数的对象；需要知道的是列表、集合和字典类型的数据不是可哈希对象，所以它们不能作为集合中的元素)。
        e2. 集合只能包含不可变的类型元素？
        e3. 创建集合时，既可以使用{...}，也可以使用set([iterable])函数。但是创建空集合的话只能使用set()，而不能使
            使用{}，因为{}是用来创建空字典的。
        e4. iterable为可迭代对象，是指可以一次返回它的一个元素，比如前面提到的字符串、列表、元组都是可迭代的数据
            类型。
        e5. 和字符串、列表、元组等序列类型不同，集合中的元素不能使用下标方式访问。集合主要用来做并、交、差等集合
            运算，以及基于集合进行元素的快速检索。

    f. Dictionary(字典，可变的)
        f1. 是另一种无序的对象集合。但与集合不同，字典是一种映射类型，每一个元素是一个键(key):值(value)对。在一个
            字典对象中，键必须是唯一的，即不同元素的键不能相同；另外键必须是可哈希数据, 值可以是任意类型。
        f2. 键只能是不可变的类型？另外如果键重复，那么重复键对应的值后面会把前面的值覆盖掉。
        f3. 字典作为可迭代对象时只有键参与。
        f4. 创建字典时，既可以用{...}，也可以使用dict函数。如果要创建一个空字典可以使用{}或dict()。
        f5. 如果在创建字典的同时，需要给出字典中的元素，如下创建的字典对象的元素完全相同：
                a= {'one':1, 'two':2, 'three':3}
                a= dict(one=1, two=2. three=3) #dict(**kwarg),其中形参 **kwarg是一个或多个赋值表达式。
                a= dict([('one', 1),('two', 2),('three', 3)]) #其中形参是元组的列表(列表元素为元组)。
                a= dict({'one':1, 'two':2, 'three':3}) #其中形参是一个已有的字典。
                a= dict(zip(['one', 'two', 'three'],[1, 2, 3])) #zip返回的是一个迭代器。
            注意zip函数的参数是多个可迭代的对象(列表等)，功能是将不同对象中对应元素打包成元组，然后返回由这些
            元组组成的列表。在Pyton3.x中为了减少内存，zip函数返回的是一个对象(迭代器)，可以通过list将其转为
            列表。
        f6. 在访问字典中的元素时不能通过数字下标方式访问，而是通过键访问，即[key]。

6) 运算符
    a. 占位运算符(比如%d、%f或%F等)
        a1. 比如s1='%s上次数学成绩为%5d, 本次成绩为%5d, 成绩提高%08.2F' %('小明'， 85， 90， 5/85)
        a2. 由于%作为占位符的前缀字符，因此对于有占位符的字符串，表示一个%时需要写成%%；比如执行如下:
            print('%.2f%%', %(20.35))将输出20.35%。
    b. 算符运算符(运算对象为数值型数据)
        b1. /(除)，比如print(10/3)结果为3.3333333333333335。计算机中数据都是二进制存储的，然而十进制
            小数和二进制之间转换时可能产生精度损失，所以在输出时，结果与实际计算结果之间存在偏差。
        b2. //(整除)，类似于C/C++中的/，返回a/b的向下取整的整数部分
        b3. **(乘方)
        b4. %(取余)，比如print(-15%4)，输出为1，因为-15-(-15/4)*4 = 1
    c. 赋值运算符
        c1. 从Python3.8开始引入了海象运算符(:=)，它可以在表达式内部为变量赋值。例如：
            string = "Hello"
            print((Lengh:=len(string)) + 5)
        c2. y+=x等价于y=y+x，区别就是前者为原地操作，而后者为新建操作。类似的还有//=、**=等等都是原地操作。
        c3. 多目标赋值，比如：
                a = b = c = [1, 2, 3]
                a, b, c = [3, 4, 5]
                [a, b, c] = [3, 4, 5]
    d. 比较运算符
        ==、!=、<、>、<=、>=
    e. 逻辑运算符
        e1. 优先级：not > and > or
        e2. 对于and，左边为False,返回左边，否则返回右边。对于or左边为True返回左边，否则返回右边。
        e3. 注意Node/False/0/空字符串/空列表/空元组/空字典/空集合都被认为是False。
        e4. 另外有二个内置函数all(iterable)和any(iterable)
    f. 位运算符
        &、|、^、<<、>>、~
    g. 身份运算符(用于比较两个对象是否有同样的内存首地址)
        g1. is：比如x is y，如果x和y对应同样的存储单元，即同样的内存首地址(id(x) == id(y))，则返回True；
            否则返回Flase。
        g2. is not：比如x is not y，如果x和y不对应同样的存储单元，则返回True；否则返回Flase。
    h. 成员运算符(用于判断一个可迭代对象中是否包含某个元素, 如果可迭代对象为字典则判断键即可)
        h1. in：比如x in y，如果x是可迭代对象y的一个元素，则返回True; 否则返回False
        h2. not in：比如x not in y，如果x不是可迭代对象y中的一个元素，则返回True；否则返回False
    i. 序列运算符(用于字符串、列表、数组等序列的运算符)
        i1. +(拼接)：x+y,将序列x和序列y中的元素连接，生成一个新的序列。
        i2. *(重复)：x*n,将序列x中的元素重复n次，生成一个新的序列。

    
7) pass(可以用三个点...来代替)
    a. pass表示一个空操作，只起到一个占位符的作用，执行时什么都不做。
    b. 在某些必要的语句还没有编写的情况下，如果要运行程序，则可以先在必要语句处写上pass,使得程序不存在语法
        错误使得程序可以正常运行。

8) 条件语句(其中elif和else都是可选项)
        if 条件1:
            语句序列
        elif 条件2：
            语句序列
        ......
        else:
            语句序列
10) 循环语句
    a. for循环
        与C/C++中的for循环不同，Python中的for循环用于遍历可迭代对象中的每一个元素，并根据当前访问的元素做
        数据处理，其语法如下：
            for 变量名 in 可迭代对象：
                语句序列
        需要注意range([beg],end,[step])函数中step允许为负值，如果beg省略默认从0开始，生成的对象中不包含end。
        使用for循环时，如果需要遍历一个数列中的所有数字，则通常使用range函数返回一个可迭代对象(这个可迭代对象
        是一个不可变的序列)。通过list可以将该对象转换为列表。
    b. while循环
        while 循环条件:
            语句序列
    c. break
        用于跳出for循环或while循环。对于多重循环，跳出它所在的最近的那重循环。
    d. continue
        用于结束本次循环并且开始下一次循环。
    e. else
        在for循环和while循环后面可以有else分支，当for循环已经遍历完或while循环的条件为Flase时，就会执行else
        分支中的语句。需要注意的是当for或while循环中通过break跳出时，循环后的else分支不会执行。

11) 函数
    a. 默认参数：
        就是缺省参数(通常放在位置参数的后面部分, 另外默认参数不能放在**kwargs的后面)。当调用该函数时，
        如果没有为某些形参传递对应的实参，则这些形参会自动使用默认参数值。
    b. 关键字参数：
        在函数调用时除了通过位置关系来体现实参与形参的对应关系的方法(即位置参数)，还有一种使用关键字参数的
        方法，其形式为"形参=实参"。使用关键字参数调用函数时，实参的传递顺序可以与形参列表中形参的顺序不一致。
        这样当一个函数的很多参数都有默认值，而我们只想对其中一小部分带默认值的参数传递实参时，就可以直接通过
        关键字参数的方法来进行实参传递，而不必考虑这些带默认值的参数在形参列表中的实际位置。例如：
            def si(name, chineselevel='A', country='中国'):
                print('姓名:%s, 中文水平:%s, 国家:%s'%(name, chineselevel, country))
            si('小李')  #chineselevel和country都有默认参数，所以在调用时只给name传递实参。
            si('皮特', country="美国")  #第一个参数使用位置参数形式，第二个参数使用关键字参数形式。位置参数和关键
                                        #字参数可以混合使用，但必须位置参数在前，关键字参数在后。
            si(country='美国', chineselevel='一般'， name='约翰') #把所有的参数都设置为关键字参数的形式
    c. 不定长参数：
        c1. 在调用函数时可以接收任意数量的实参，这些实参在传递给函数时会封装(封包)成元组(位置参数)或字典(关键字
        参数)形式。一般情况下，不定长参数放在形参列表的最后，前面传入的实参与普通形参一一对应，而后面剩下的实
        参会被封装成元组或字典后传给不定长参数。对于使用位置参数形式的不定长参数，Python也允许将普通形参放在
        不定长参数的后面，但此时要求在调用函数时必须使用关键字参数方式给不定长参数后面的形参传递实参(对于有默认
        参数的形参，在调用函数时也可以不传入相应实参)。
        c2. 带不定长参数的函数的定义方法如下所示：
            def 函数名([普通形参列表,] *不定长参数名 [,普通形参列表]):  # 不定长参数对应的是一组位置参数
                函数体

            或

            def 函数名([普通形参列表,] **不定长参数名): #不定长参数对应的是一组关键字参数
                函数体
    d. 拆分参数(解包)列表
        如果一个函数所需要的参数已经存储在列表、元组或字典中，就可以直接从列表、元组或字典中拆分出函数所需要的参数，
        其中列表、元组拆分出来的结果作为位置参数，而字典拆分出来的结果为关键字参数。
        例如：
        def sumval(*args):
            sum = 0
            for i in args:
                sum+=i
            print('求和结果为 ', sum)
        ls = [3, 5.2, 7, 1]
        sumval(*ls) #等价于sumval(3, 5.2, 7, 1)
    e. 返回值
        e1. 如果在函数中没有显式地写return语句，那么就会隐式地添加一个什么数据都不返回的return语句，即return None(或直接return)
        e2. 通过return不仅能返回数值数据，也可以返回字符串、列表、元组等数据。比如
        def getElements():
            return 1, 2, 3 #返回3个数值数据，实际上这3个数据会打包成一个元组返回，等效于return (1, 2, 3)
    f. 局部变量和全局变量
        f1. 在一个函数中定义的变量就是局部变量(包括形参)，其作用域是从定义局部变量的位置至函数结束的位置。在所有
        函数外部定义的变量就是局部变量，其在所有函数中都可使用。
        f2. global关键字：要在一个函数中使用global关键字，可以声明在该函数中使用的是全局变量，而非局部变量。比如
            def my_func():
                global x    #通过global关键字声明为该函数中使用的是全局变量x, 而不是重新定义一个
                x = 100 #将全局变量x赋为100
            在一个函数中要修改全局变量的值，必须使用global关键字声明使用该全局变量。虽然在不修改全局变量值的情况
            下可以省略global关键字，但不建议这么做，因为这样会降低程序的可读性。
        f3. nonlocal关键字：在Python中函数的定义可以嵌套，即在一个函数的函数体中可以包含另一个函数的定义。通
        过nonlocal关键字，可以使内层的函数直接使用外层函数中定义的变量。
            def outer():
                x = 10 #定义局部变量x并赋值为10
                def inner():
                    nolocal x #nolcal声明
                    x = 20  #使用外层函数outer中定义的变量x,而不是重新定义一个
                inner() #在outer函数中调用inner函数
            outer()
        f4. 闭包：如果在内层函数中使用了外层函数的局部变量，并且外层函数的返回值是内层函数的引用，就构成了闭包。
            定义在外层函数中但由内层函数使用的变量称为自由变量。一般情况下，如果一个函数结束，那么该函数中定义的
            局部变量都会释放。然而闭包是一种特殊情况，外层函数在结束时会发现其定义的局部变量将来会在内层函数中使用，
            此时外层函数就会把这些自由变量绑定到内层函数。因此所谓闭包，实际上就是将内层函数的代码以及自由变量(由
            外层函数定义，但会由内层函数使用)打包在一起(会将自由变量保存到内部函数的__closure__属性中以供内部函数使用)。
            def outer(x):
                y = 10
                def inner(z):
                    nolocal x,y
                    return x+y+z
                return inner    #返回嵌套函数的inner的引用

    g. lambda函数
        g1. 也称为匿名函数，是一种不使用def定义函数的形式，其作用是能快速定义一个简短的函数。lambda函数的函数体只是
            一个表达式，所以lambda函数通常只能实现比较简单的功能。
        g2. 匿名函数可以在需要函数对象的任意地方使用(比如赋值给变量，作为参数传入其函数等)，因为匿名函数可以作为一个
            表达式，而不是一个结构化的代码块。
        g3. lambda后面的参数可以有，也可以没有，并且可以有多个；但是冒号后面的表达式必须有，并且只能有一个。表达式
            的计算结果即为该lambda函数的返回值。
        g4. 可以将lambda函数赋给一个变量，然后通过该变量调用相应的lambda函数。
    
    h. 函数装饰器(装饰器包括函数装饰器和类装饰器)
        h1. 利用装饰器，可以在不修改已有函数的情况下向已有函数中注入代码，使其具备新的功能。一个装饰器可以为多个函数注入
        代码，一个函数也可以注入多个装饰器的代码。

        def deco1(func):    #定义一个装饰器(装饰器实际上就是闭包)，在外层函数的形参列表中只有一个形参func,接收要装饰的函数，
            def inner1(*args, **kwargs): 
                print('deco1 begin')
                func(*args, **kwargs)   #在内层函数中直接调用func即表示执行所装饰的函数中的代码
                print('deco1 end')
            return inner1
        def deco2(func):    #定义一个装饰器
            def inner2(*args, **kwargs)
                print('deco2 begin')
                func(*args, **kwargs)
                print('deco2 end')
            return inner2
        #在要装饰的函数前面写上“@装饰器名”即可将装饰器中的代码注入该函数(f1)中,因此下面三行代码，会将deco1中的代码注入f1
        #函数中，deco1中的func(*arg, **kwargs)即对应f1函数的调用。
        @deco1  
        def f1(a, b):   #f1 = inner1
            print('a+b=', a+b)
        #当一个函数前面有多个“@装饰器名”的时候，将按照从后至前的顺序依次装饰。因此，下面先使用deco2装饰f2函数，即在f2函数的代码
        #前注入print('deco2 begin')，在f2函数的代码后注入print('deco2 end')；然后在前面装饰的基础上使用deco1装饰，即在已装饰
        #代码前注入print('deco1 begin')，在已装饰代码后注入print('deco1 end')。
        @deco1
        @deco2
        def f2(a, b, c):
            print('a+b+c=', a+b+c)
        if __name__ '__main__:
            f1(3, 5)    #在调用f1函数时，会先输出deco1 begin, 再执行f1函数中的代码输出a+b=8,最后输出deco1 end。
            f2(1, 3, 5)

        h2. 上述例子中，f2函数装饰后，其实际执行代码为：
            print('deco1 begin')
            print('deco2 begin')
            print('a+b+c=', a+b+c)
            print('deco2 end')
            print('deco1 end')
        
        h3. 利用装饰器可以将日志处理、执行时间计算等较为通用的代码注入不同的函数中，从而使得代码更简洁。
        h4. 将装饰器内层函数的形参列表写为“*args，**kwargs”，表示要装饰的函数可以具有任意形式的形参列表；当然也可以根据实际情况来，如果
        要注入函数的形参列表形式固定，也可以不使用这种通用形式。

12) 类与对象(与C++不同，Python中提供的基本数据类型也是类，比如int、float等)
    a. 与类相关的3个内置函数
        a1. isinstance()
            用于判断一个对象所属的类是否是指定类或指定类的子类
        a2. issubclass()
            用于判断一个类是否是另一个类的子类
        a3. type()
            用于获取一个对象所属的类；需要注意type(int)返回<class type>，说明int这个类型本身也是一个对象，它是由type生成的(type为metaclass)。
    b. 可以直接创建新的类，也可以基于一个或多个已有的类创建新的类；既可以创建一个空的类(pass)，然后动态添加属性和方法，也可以在创建类的同时设置
        属性和方法。类的定义形式如下：
            class 类名：
                语句1
                语句2
                ...
                语句N
    c. 定义了一个类后，就可以创建该类的实例对象，其语法格式为：类名(参数表)
    d. 属性(包括类属性和对象属性)
        d1. 类属性既可以通过类名(Python中一切皆对象)调用，也可以通过实例对象去调用：类名或对象名.属性名。然而实例属性只能通过实例对象调用名
            调用不能通过类名调用。
        d2. 类属性是所有实例对象所公有的，实例属性是每一个实例对象所私有。另外实例属性只能通过实例对象去修改；类属性也只能通过类名去修改。
        d3. 当实例属性和类属性同名时，实例对象优先调用实例属性。
        d4. 私有属性：Python中规定，在定义类时，如果一个类属性名是以“__”开头，则该属性为私有属性。在类的外面不能直接通过类对象直接访问类的私有属性，
            如果非要访问的话需要在私有属性名前加上“_类名”，即：对象名._类名__私有属性名。另外需要注意也有私有方法，其定义方式也是在方法名前加两个
            下划线，一般也是在类的内部访问。需要注意的是子类无法继承父类的私有属性和私有方法。 
        d5. 动态定义类属性和实例属性：当使用实例对象修改的实例属性不存在时，会增加一个实例属性(动态地为已创建地对象绑定新的属性，需要注意当为一个
            对象动态绑定新的属性后，只是该对象具有该属性，其他对象和类都没有该动态绑定的属性)；当使用类修改的类属性不存在时会增加一个类属性。当然
            对于方法也是类似。 这种除了在定义类时定义属性和方法外，还可以动态地为已经创建的对象或类绑定新的属性和方法的机制机制称为动态扩展。当然在
            定义类时，Python也提供了__slots__变量以限制这种可动态扩展的属性。        
    e. 方法
        e1. 类中的方法分为两类：内置方法和其他方法(对象方法、类方法、静态方法)，其中内置方法是在特定情况下由系统自动执行。
        e2. 在定义类的对象方法时，要求第一个参数需要对应调用方法时所使用的实例对象(一般约定俗成命名为self，当然也可以使用别的名)。在通过类的
            实例对象调用类中的普通方法时，并不需要传入self参数的值，self会自动对应调用该方法时所使用的对象。需要注意必须通过实例对象调用，而不能
            通过类名直接调用(若真需要通过类名调用的话其实也有办法，就是需要手动将实例对象作为第一个参数传入，稍微有点麻烦)。因为通过实例对象调用时
            会自动将该实例对象传给self，而通过类调用时则不会有这个隐含的参数传递。
        e4. 类方法是指用@classmethod修饰的方法，其第一个参数是类本身(而不是类的实例对象)。类方法的特点是既可以通过类名直接调用，也可以通过类的实例
            对象调用(本质上是使用实例对象的类型去调用类方法，即type(实例对象名).类方法名)
        e5. 静态方法是使用@staticmethod修饰的方法。与类方法相同，静态方法也可以直接通过类名调用，也可以通过类的实例对象调用。与类方法不同的是，静态
            方法中没有类方法中的第一个参数。
        e6. 类中的属性可以直接访问和赋值，这为类的使用者提供了方便，但也带来了问题：类的使用者可能会给一个属性赋上超出有效范围的值。为了解决这个问题，
            Python提供了@property装饰器，可以将类中属性的访问和赋值操作自动转为方法调用，这样可以在方法中对属性值的取值范围做一些条件限定。


    f. 构造(__init__)和析构(__del__)：创建和销毁对象时自动执行的内置方法
        f1. __new__用来创建实例对象并返回，__init__用来给返回的实例对象制定属性(初始化)：
            每一次实例化(类名就像函数那样被调用就是实例化，当然实例对象也可以向函数那样被调用，这需要由内置的__call__来实现)时会
            自动调用__new__(cls, *args, **kwargs)这个内置方法把需要实例化的类传给作为参数传给cls, 传入的其他参数会给*args和**kwargs进行打包；
            然后__new__就会根据cls构建出一个实例对象返回给调用方。这里需要注意在自定义类时一般不需要自己再去实现__new__方法了，因为直接使用其父类
            的__new__就已经够了。
        f2. __new__返回后就紧接着调用__init__，此时会自动把__new__创建的实例对象作为实参传给其第一个参数self(从这里也可看出self是一个指向实例
            本身的引用)，另外传入__new__除了cls的其他实参也会传入这里的__init__，然后执行__init__的函数体就会对该实例对象的对象属性进行定
            制(__init__不能有返回值)。这里需要注意，在自定义类时，若不需要定制属性，直接使用父类的__init__就可以了，不需要再单独实现。
        f3. 在销毁一个对象时，会自动执行__del__，它负责待销毁对象的资源清理工作，比如关闭文件等。类对象一般在以下3种情况中被销毁：一种是局部变
            量的作用域结束，比如被调函数执行完毕后，其内部的对象被销毁；一种是使用del删除对象；一种是程序结束时。
            class Student:
                def __init__(self, name='未知'):    #也可以设置默认参数
                    print('构造方法被调用')
                    self.name = name
                def PrintInfo(self):
                    print('姓名： %s' %self.name)
                def __del__(self):
                    prinf('姓名为%s的对象被销毁'%self.name)
            if __name__=='__main__':
                stu=Student(“xiaohong”) #创建Student类对象stu,自动执行构造方法
                stu.PrintInfo()
                del stu
    g. __call__
        通过在一个类中定义__call__方法，可以支持如下写法：对象名(实参表) #等价于对象名.__call__(实参表)
    
    h. 其他的一些常用内置方法
            g1. __str__方法：在调用str函数对类对象进行处理时或调用format()和print()时会自动执行，__str__方法的返回值必须是字符串。
            g2. 比较对象大小的内置方法：
                __gt__(self, other)   #进行self > other运算时自动执行。
                __lt__(self, other)
                __ge__(self, other)
                __le__(self, other)
                __eq__(self, other)
                __ne__(self, other)
    i. 继承
        h1. 通过继承，可以基于已有类创建新的类，新类除了继承已有类的所有属性和方法(子类继承后会拥有父类中的所有的非私有属性和方法)，
            还可以根据需要增加新的属性和方法，另外子类可以对父类中的方法进行重新定义。继承可以分为单继承和多重继承。
        h2. 定义子类时需要指定父类，其语法格式为：
            class 子类名(父类名1，父类名2，...,父类名N)
                语句1
                语句2
                ...
                语句N
        h3. 在Python中，所有的数据类型都是类类型，所有的变量都是类对象。所有的类都直接或间接继承自object类，即object是Python类层次
            结构中的第一层的类。我们在定义类时如果没有显式地为其指定父类，则该类会有一个隐含的父类object。
        h4. 在Python中提供了两个和继承相关的内置函数：
            isinstance(对象名，类名)
            issubclass(类名1， 类名2)
    
    j. 多态
        i1. 通过多态，可以使得在执行同一条语句时，能够根据实际使用的对象类型决定调用哪个方法。
        i2. 方法重写：方法重写是指子类可以对从父类继承过来的方法进行重新定义，从而使得子类可以表现出与父类对象不同的行为。方法重写
            是多态的基础。从下面示例的结果可以看出，在调用PrintPersonInfo时，系统会根据传入的实参对象的类型决定执行哪个类中定义
            的PrintInfo方法，这就是所谓的多态，即在执行同样代码的情况下，系统会根据对象实际所属的类去调用相应类中的方法。
    
            class Persion:
                def __init__(self, name):
                    self.name=name
                def PrintInfo(self)
                    print('姓名：%s'%self.name)
            class Student(Persion):
                def __init__(self, sno, name):
                    self.sno=sno
                    self.name=name
                def PrintInfo(self)
                    print('学号:%s, 姓名:%s'%(self.sno, self.name))
            def PrintPersonInfo(person):
                print('结果', end=‘#’)
                persion.PrintInfo()
            
            if __name__=='__main__':
                p=Person('xiaoming')
                stu=Student('1810100', 'xiaoming')
                PrintPersonInfo(p)  # 结果#姓名：xiaoming
                PrintPersonInfo(stu)    # 结果#学号: 1810100, 姓名：xiaoming
    k. super方法
        j1. super是内置的类，可以调用指定类的父类(可放在类内也可放在类外)，它的适用场景为：在子类重写父类的方法后，想再使用父类
            的该方法。
        j2. super方法用于获取(返回)父类的代理对象，以执行已在子类中被重写的父类方法。其有两个参数，第一个参数是要获取父类代理对象
            的类名。第二个参数可以是对象名或类名，如果传入对象名，则该对象所属的类必须是第一个参数指定的类或该类的子类，找到的父类
            对象的self会绑定到这个对象上；如果传入类名，则该类必须是第一个参数指定的类的子类。super([类名[, 对象名或类名]])      
        j3. 在一个类A的定义中调用super方法时，可以将两个参数都省略，此时super()等价于super(A, self)，即获取当前A的父类代理对象，且
            获取到的父类代理对象中的self绑定到当前A类对象的self上。
    l. 元类(metaclass)
        k1. 一个metaclass就是一个用来创建其他class的类，而type就是所有类默认的metaclass。可以将metaclass看成创建类时所使用的模板，
            也可以理解为用于创建类的类。
        k2. 你可以在定义的时候指定metaclass：例如class Person(object, metaclass=type) #这里扩号中的都是默认的
        k3. 我们也可以以type作为父类定义自己的metaclass，然后用该metaclass再去创建类，最后用类创建对象。

13) monkey patch(猴子补丁)
    a. 是指在运行时动态替换已有代码，而不需要修改原始代码。
    def sum(a, b):
        return a + b
    def NewSum(*args):
        s = 0
        for i in args:
            s += i
        return s
    
    sum = NewSum    #将NewSum传给sum, 后面再调用sum函数，实际上就是执行NewSum函数
    print(sum(1, 2, 3, 4, 5))

    b. 猴子补丁主要用于在不修改已有代码的情况下修改其功能或增加对新功能的支持。例如在使用第三方模块时，模
    块中的某些地方可能无法满足我们的开发需求。此时，我们可以在不修改这些方法代码的情况下，通过猴子补丁用一些
    自己编写的新方法对其进行替代，从而实现一些新的功能。

14) 单例模式
    指的是在程序运行时确保某个类最多只有一个实例对象。

15) 鸭子类型(duck typing)
    在鸭子类型中关注的不是对象所属的类，而是一个对象能够如何使用。在Python中编写一个函数，传递实参前其参数的类型
    并不确定，在函数中使用形参进行操作时，只要传入的对象能够支持该操作程序，就能正常执行。例如：
        class Person:
            def CaptureImage(self):
                print('Person_CaptureImage')
        class Camera:
            def CaptureImage(self):
                print('Camera_CaptureImage')
        def CaptureImageTest(arg):
            arg.CaptureImage()
        if __name__=='__main__':
            p=Person()
            c=Camera()
            CaptureImageTest(p) #输出Person_CaptureImage
            CaptureImageTest(c) #输出Camera_CaptureImage

    可以看出鸭子类型与前面介绍的多态非常类似，实际上Python中的多态也是借助鸭子类型实现，与C++、Java等语言中的多态并不
    是同一含义。


16) 常用内置函数
    a. enumerate函数
        如果希望不仅可以获得每一个元素的值，而且能获取每一个元素的索引，则可以改成如下所示的方式：
            ls = ['Python', 'C++', 'Rust']
            for k in range(len(ls)):
                print(k, ls[k])
        
        除了上述方式外，还可以使用enumerate函数来访问每个元素的索引，代码如下所示：
            ls = ['Python', 'C++', 'Rust']
            for k, v in enumerate(ls): #k保存当前元素的索引，v保存当前元素的值
                print(k, v)
        enumerate函数的功能就是将一个可迭代对象组成一个索引序列(enumerate)对象，利用这个索引序列对象可以
        同时获取每个元素的索引和值。另外enumerate函数还可以指定索引的起始值 
            ls = ['Python', 'C++', 'Rust']
            for k, v in enumerate(ls, 1): #索引从1开始(默认为0)
                print(k, v)